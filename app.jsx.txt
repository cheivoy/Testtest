import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import Tesseract from 'tesseract.js';
import { SYSTEM_CONSTANTS, toNum, calculateDamage, generateDefenseChartData, generateAttackChartData } from './utils.js';

const ImageUploader = ({ setInputs, type }) => {
  const [images, setImages] = React.useState([]);
  const [progress, setProgress] = React.useState(0);
  const [error, setError] = React.useState('');

  const preprocessImage = (image, callback) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      let sum = 0;
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        sum += avg;
      }
      const threshold = sum / (data.length / 4) > 128 ? 128 : sum / (data.length / 4);
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        const value = avg > threshold ? 255 : 0;
        data[i] = data[i + 1] = data[i + 2] = value;
      }
      ctx.putImageData(imageData, 0, 0);
      callback(canvas.toDataURL());
    };
    img.src = URL.createObjectURL(image);
  };

  const parseText = (text, type) => {
    const values = {};
    const regex = /([\u4e00-\u9fa5]+[\u4e00-\u9fa5\sï¼š:]*)\s*[:ï¼š]*\s*([\d.,\/%-]+(?:\s*[-â€“â€”]\s*\d+)?)/g;
    let match;
    const unmatched = [];

    while ((match = regex.exec(text)) !== null) {
      const label = match[1].trim().replace(/\s+/g, '');
      let value = match[2].replace(/[,]/g, '').replace('%', '');

      if (type === 'attacker') {
        if (label.includes('æŠ€èƒ½å€ç‡')) values.skill_multiplier = value;
        if (label.includes('æ”»æ“Š') && !label.includes('å…ƒç´ æ”»æ“Š') && !label.includes('æ”»æ“Š%')) {
          const [low] = value.split(/[-â€“â€”]/).map(Number);
          values.D = low.toString();
        }
        if (label.includes('å…ƒç´ æ”»æ“Š')) values.E = value;
        if (label.includes('æœƒå¿ƒæ•¸å€¼')) values.b_c = value;
        if (label.includes('æœƒå¿ƒå‚·å®³')) values.d_c = (parseFloat(value) / 100).toString();
        if (label.includes('æµæ´¾å…‹åˆ¶') && !label.includes('æµæ´¾å…‹åˆ¶%')) {
          const [baseValue] = value.split('/').map(v => v.trim());
          values.R = baseValue;
        }
        if (label.includes('æµæ´¾å…‹åˆ¶%')) {
          const [, percentValue] = value.split('/').map(v => parseFloat(v));
          values.flow_percent = (percentValue / 100).toString();
        }
        if (label.includes('å‘½ä¸­')) values.h = value;
        if (label.includes('ç ´é˜²')) values.b_d = value;
        if (label.includes('ç ´ç›¾')) values.b_s = value;
        if (label.includes('å¿½è¦–å…ƒç´ æŠ—æ€§')) values.b_e = value;
        if (label.includes('å¢å‚·')) values.damage_increase = (parseFloat(value) / 100).toString();
        if (label.includes('æŠ€èƒ½å¢å‚·')) values.skill_damage_increase = (parseFloat(value) / 100).toString();
        if (label.includes('é‡‘å‘¨å¤©')) {
          if (value.includes('1ç´š') || value.includes('1')) values.gold_i = '0.03';
          else if (value.includes('2ç´š') || value.includes('2')) values.gold_i = '0.04';
          else if (value.includes('3ç´š') || value.includes('3')) values.gold_i = '0.05';
          else values.gold_i = '0';
        }
      } else if (type === 'defender') {
        if (label.includes('æ°£è¡€')) values.hp = value.split('/')[0];
        if (label.includes('é˜²ç¦¦')) values.d_d = value;
        if (label.includes('æŠ—æœƒå¿ƒæ•¸å€¼')) values.b_c_defense = value;
        if (label.includes('æœƒå¿ƒé˜²ç¦¦')) values.d_c_defense = (parseFloat(value) / 100).toString();
        if (label.includes('æ ¼æ“‹')) values.b_b = value;
        if (label.includes('å…ƒç´ æŠ—æ€§')) values.d_e = value;
        if (label.includes('å‚·å®³æ¸›å…')) values.damage_reduction = (parseFloat(value) / 100).toString();
        if (label.includes('æµæ´¾æŠµç¦¦') && !label.includes('æµæ´¾æŠµç¦¦%')) {
          const [baseValue] = value.split('/').map(v => v.trim());
          values.d_f = baseValue;
        }
        if (label.includes('æµæ´¾æŠµç¦¦%')) {
          const [, percentValue] = value.split('/').map(v => parseFloat(v));
          values.flow_resist_percent = (percentValue / 100).toString();
        }
        if (label.includes('æ°£ç›¾')) values.d_s = value;
        if (label.includes('æŠ€èƒ½æ¸›å…')) values.skill_damage_reduction = (parseFloat(value) / 100).toString();
      } else if (type === 'healing') {
        if (label.includes('æ²»ç™‚å¼·åº¦')) values.healing_power_equip = value;
        if (label.includes('æ²»ç™‚åŠ æˆ')) values.healing_percent = (parseFloat(value) / 100).toString();
      }
    }

    const lines = text.split('\n');
    lines.forEach(line => {
      if (line.trim() && !regex.test(line)) unmatched.push(line);
    });
    if (unmatched.length > 0) console.warn('Unmatched OCR text:', unmatched);

    return values;
  };

  const handleImageUpload = async (e) => {
    const files = Array.from(e.target.files).slice(0, 3);
    if (files.length > 3) {
      setError('æœ€å¤šåªèƒ½ä¸Šå‚³3å¼µåœ–ç‰‡');
      return;
    }
    setImages(files);
    setProgress(0);
    setError('');

    try {
      const results = await Promise.all(
        files.map(async (file, index) => {
          const progressIncrement = 100 / files.length;
          return new Promise((resolve) => {
            preprocessImage(file, async (processedImage) => {
              const { data: { text } } = await Tesseract.recognize(processedImage, 'chi_tra', {
                logger: (m) => {
                  if (m.status === 'recognizing text') {
                    setProgress((prev) => prev + (m.progress * progressIncrement));
                  }
                },
              });
              resolve(parseText(text, type));
            });
          });
        })
      );

      const mergedValues = results.reduce((acc, curr) => ({ ...acc, ...curr }), {});
      setInputs((prev) => ({ ...prev, ...mergedValues }));
      setProgress(100);
    } catch (err) {
      console.error('OCR Error:', err);
      setError('åœ–ç‰‡è§£æå¤±æ•—ï¼Œè«‹æª¢æŸ¥åœ–ç‰‡è³ªé‡æˆ–é‡è©¦');
    }
  };

  return (
    <div className="mb-4">
      <label className="block text-sm font-medium text-gray-700 mb-2">ä¸Šå‚³å±¬æ€§æˆªåœ–ï¼ˆæœ€å¤š3å¼µï¼Œåƒ…æ”¯æŒPNG/JPGï¼‰</label>
      <input
        type="file"
        accept="image/png, image/jpeg"
        multiple
        onChange={handleImageUpload}
        className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-cherry-50 file:text-cherry-700 hover:file:bg-cherry-100"
        aria-label="ä¸Šå‚³å±¬æ€§æˆªåœ–"
      />
      {progress > 0 && progress < 100 && (
        <div className="mt-2">
          <div className="w-full bg-gray-200 rounded-full h-2.5">
            <div className="bg-cherry-500 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
          </div>
          <p className="text-sm text-gray-600 mt-1">è§£æé€²åº¦ï¼š{progress.toFixed(0)}%</p>
        </div>
      )}
      {error && <p className="text-sm text-red-600 mt-2">{error}</p>}
      {images.length > 0 && (
        <div className="mt-4 grid grid-cols-3 gap-2">
          {images.map((image, index) => (
            <img key={index} src={URL.createObjectURL(image)} alt={`é è¦½ ${index + 1}`} className="w-full h-24 object-cover rounded-md" />
          ))}
        </div>
      )}
    </div>
  );
};

const DamageCalculator = () => {
  const [inputs, setInputs] = React.useState({
    skill_multiplier: "1518",
    D: "5000",
    E: "800",
    b_c: "900",
    d_c: "1.8",
    R: "500",
    h: "700",
    b_d: "2000",
    b_s: "700",
    b_e: "0",
    flow_percent: "0",
    damage_increase: "0",
    skill_damage_increase: "0",
    d_s: "2000",
    d_f: "2000",
    d_d: "5000",
    d_e: "0",
    b_b: "600",
    hp: "80000",
    b_c_defense: "550",
    d_c_defense: "0",
    flow_resist_percent: "0",
    damage_reduction: "0",
    skill_damage_reduction: "0",
    lambda_1: SYSTEM_CONSTANTS.lambda_1.toString(),
    lambda_2: SYSTEM_CONSTANTS.lambda_2.toString(),
    lambda_3: SYSTEM_CONSTANTS.lambda_3.toString(),
    lambda_4: SYSTEM_CONSTANTS.lambda_4.toString(),
    W: "1",
    gold_i: "0"
  });
  const [inputErrors, setInputErrors] = React.useState({});
  const [previousResult, setPreviousResult] = React.useState(null);
  const [previousInputs, setPreviousInputs] = React.useState(null);

  const goldOptions = [
    { value: "0", label: "ç„¡é‡‘å‘¨å¤©" },
    { value: "0.03", label: "é‡‘å‘¨å¤©1ç´š" },
    { value: "0.04", label: "é‡‘å‘¨å¤©2ç´š" },
    { value: "0.05", label: "é‡‘å‘¨å¤©3ç´š" },
  ];

  const elementWeaknessOptions = [
    { value: "1", label: "ç„¡å…ƒç´ å¼±é»" },
    { value: "1.5", label: "æœ‰å…ƒç´ å¼±é»" },
  ];

  const handleChange = (e) => {
    const { name, value } = e.target;
    if (name === 'gold_i' || name === 'W') {
      setInputs((prev) => ({ ...prev, [name]: value }));
      setInputErrors((prev) => ({ ...prev, [name]: '' }));
    } else {
      if (value === '') {
        setInputs((prev) => ({ ...prev, [name]: '0' }));
        setInputErrors((prev) => ({ ...prev, [name]: '' }));
        return;
      }
      const numValue = parseFloat(value);
      if (isNaN(numValue)) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è«‹è¼¸å…¥æœ‰æ•ˆæ•¸å­—' }));
        return;
      }
      if (numValue < 0) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
        return;
      }
      if (numValue > 100000) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§ç‚º100000' }));
        return;
      }
      if (['flow_percent', 'damage_increase', 'skill_damage_increase', 'd_c_defense', 'flow_resist_percent', 'damage_reduction', 'skill_damage_reduction'].includes(name)) {
        if (numValue < 0 || numValue > 1) {
          setInputErrors((prev) => ({ ...prev, [name]: 'ç™¾åˆ†æ¯”å€¼å¿…é ˆåœ¨0åˆ°1ä¹‹é–“' }));
          return;
        }
      }
      setInputs((prev) => ({ ...prev, [name]: value }));
      setInputErrors((prev) => ({ ...prev, [name]: '' }));
    }
  };

  const saveCurrentResult = () => {
    setPreviousResult(calculateDamage(inputs));
    setPreviousInputs({ ...inputs });
  };

  const CustomTooltip = ({ active, payload, label, isDelta }) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
          <p className="text-sm text-gray-700 font-medium">å±¬æ€§é»: {label}</p>
          {payload.map((entry, index) => (
            <p key={index} className="text-sm text-gray-600">
              <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  const result = calculateDamage(inputs);
  const { deltaData, reductionData } = generateDefenseChartData(inputs);

  return (
    <div className="p-4 container mx-auto min-h-screen">
      <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
        <h1 className="text-xl md:text-2xl font-bold text-center text-white">é˜²å®ˆè¨ˆç®—å™¨</h1>
        <p className="text-center text-white text-opacity-90 text-sm mt-1">å¦‚æœ‰å•é¡Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@ç·£å®šä»Šç”Ÿ</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
          <div className="flex items-center mb-4">
            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
            <h2 className="font-bold text-base md:text-lg text-gray-800">æ”»æ“Šæ–¹åƒæ•¸</h2>
          </div>
          <ImageUploader setInputs={setInputs} type="attacker" />
          <div className="grid grid-cols-1 gap-3">
            {[
              { key: "skill_multiplier", label: "æŠ€èƒ½å€ç‡", icon: "ğŸ”¥", tooltip: "å¦‚æŠ€èƒ½å€ç‡ç‚º300%ï¼Œè¼¸å…¥300" },
              { key: "D", label: "æ”»æ“Š", icon: "âš”ï¸" },
              { key: "E", label: "å…ƒç´ æ”»æ“Šï¼ˆå¹³å‡ï¼‰", icon: "âœ¨" },
              { key: "b_c", label: "æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
              { key: "d_c", label: "æœƒå¿ƒå‚·å®³", icon: "ğŸ’¥", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚180%ï¼Œè¼¸å…¥1.8" },
              { key: "R", label: "æµæ´¾å…‹åˆ¶", icon: "ğŸ”„" },
              { key: "h", label: "å‘½ä¸­", icon: "ğŸ¯" },
              { key: "b_d", label: "ç ´é˜²", icon: "ğŸ›¡ï¸" },
              { key: "b_s", label: "ç ´ç›¾", icon: "ğŸ”¨" },
              { key: "b_e", label: "å¿½è¦–å…ƒç´ æŠ—æ€§", icon: "ğŸ¦ " },
              { key: "flow_percent", label: "æµæ´¾å…‹åˆ¶%", icon: "ğŸ“Š", tooltip: "ä¾‹å¦‚9.5%ï¼Œè¼¸å…¥0.095" },
              { key: "damage_increase", label: "å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "skill_damage_increase", label: "æŠ€èƒ½å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "gold_i", label: "é‡‘å‘¨å¤©", icon: "ğŸŒŸ", type: "select", options: goldOptions },
              { key: "W", label: "å…ƒç´ å¼±é»", icon: "ğŸ¦‹", type: "select", options: elementWeaknessOptions }
            ].map(({ key, label, icon, type, options, tooltip }) => (
              <div key={label} className="flex flex-col group relative">
                <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                  <span className="mr-1 md:mr-2">{icon}</span>{label}
                  {tooltip && (
                    <>
                      <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer ml-2">?</span>
                      <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded shadow-md z-10 max-w-xs">
                        {tooltip}
                      </div>
                    </>
                  )}
                </label>
                {type === "select" ? (
                  <select
                    name={key}
                    value={inputs[key]}
                    onChange={handleChange}
                    className="input-focus border-gray-200 rounded-md p-2 text-sm w-full"
                    aria-label={label}
                  >
                    {options.map(opt => (
                      <option key={opt.value} value={opt.value}>{opt.label}</option>
                    ))}
                  </select>
                ) : (
                  <input
                    type="number"
                    name={key}
                    value={inputs[key]}
                    onChange={handleChange}
                    min="0"
                    max="100000"
                    className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-md p-2 text-sm w-full`}
                    aria-label={label}
                  />
                )}
                {inputErrors[key] && (
                  <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                )}
              </div>
            ))}
          </div>
        </div>

        <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
          <div className="flex items-center mb-4">
            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
            <h2 className="font-bold text-base md:text-lg text-gray-800">é˜²å®ˆæ–¹åƒæ•¸</h2>
          </div>
          <ImageUploader setInputs={setInputs} type="defender" />
          <div className="grid grid-cols-1 gap-3">
            {[
              { key: "d_s", label: "æ°£ç›¾", icon: "ğŸ›¡ï¸" },
              { key: "d_f", label: "æµæ´¾æŠµæŠ—", icon: "ğŸ”„" },
              { key: "d_d", label: "é˜²ç¦¦", icon: "ğŸ°" },
              { key: "d_e", label: "å…ƒç´ æŠµæŠ—", icon: "ğŸ¦ " },
              { key: "b_b", label: "æ ¼æ“‹", icon: "âœ‹" },
              { key: "hp", label: "æ°£è¡€", icon: "â¤ï¸" },
              { key: "b_c_defense", label: "æŠ—æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
              { key: "d_c_defense", label: "æœƒå¿ƒé˜²ç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚25%ï¼Œè¼¸å…¥0.25" },
              { key: "flow_resist_percent", label: "æµæ´¾æŠµæŠ—%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "damage_reduction", label: "å‚·å®³æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚15%ï¼Œè¼¸å…¥0.15" },
              { key: "skill_damage_reduction", label: "æŠ€èƒ½æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" }
            ].map(({ key, label, icon, tooltip }) => (
              <div key={label} className="flex flex-col group relative">
                <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                  <span className="mr-1 md:mr-2">{icon}</span>{label}
                  {tooltip && (
                    <>
                      <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer ml-2">?</span>
                      <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded shadow-md z-10 max-w-xs">
                        {tooltip}
                      </div>
                    </>
                  )}
                </label>
                <input
                  type="number"
                  name={key}
                  value={inputs[key]}
                  onChange={handleChange}
                  min="0"
                  max="100000"
                  className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-md p-2 text-sm w-full`}
                  aria-label={label}
                />
                {inputErrors[key] && (
                  <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                )}
              </div>
            ))}
          </div>
        </div>

        <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
          <div className="flex items-center mb-4">
            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
            <h2 className="font-bold text-base md:text-lg text-gray-800">ç³»çµ±å¸¸æ•¸</h2>
          </div>
          <div className="grid grid-cols-1 gap-3">
            {[
              { key: "lambda_1", label: "ç³»çµ±å¸¸æ•¸ Î»â‚", icon: "ğŸ”¢", value: SYSTEM_CONSTANTS.lambda_1 },
              { key: "lambda_2", label: "ç³»çµ±å¸¸æ•¸ Î»â‚‚", icon: "ğŸ”¢", value: SYSTEM_CONSTANTS.lambda_2 },
              { key: "lambda_3", label: "ç³»çµ±å¸¸æ•¸ Î»â‚ƒ", icon: "ğŸ”¢", value: SYSTEM_CONSTANTS.lambda_3 },
              { key: "lambda_4", label: "ç³»çµ±å¸¸æ•¸ Î»â‚„", icon: "ğŸ”¢", value: SYSTEM_CONSTANTS.lambda_4 },
            ].map(({ key, label, icon, value }) => (
              <div key={label} className="flex flex-col">
                <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                  <span className="mr-1 md:mr-2">{icon}</span>{label}
                </label>
                <input
                  type="number"
                  value={value}
                  disabled
                  className="border-gray-200 rounded-md p-2 text-sm bg-gray-100 w-full"
                  aria-label={label}
                />
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="flex justify-center mb-6">
        <button
          onClick={saveCurrentResult}
          className="bg-cherry-500 text-white font-bold py-2 px-6 rounded-md hover:bg-cherry-600 transition-colors"
          aria-label="å„²å­˜ç•¶å‰çµæœ"
        >
          å„²å­˜ç•¶å‰çµæœ
        </button>
      </div>

      <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100 mb-6">
        <h2 className="font-bold text-base md:text-lg text-gray-800 mb-4">è¨ˆç®—çµæœ</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
          <div>
            <h3 className="font-bold text-gray-700 mb-2">ç•¶å‰çµæœ</h3>
            <div className="space-y-2 text-sm">
              <p>æœƒå¿ƒæ•¸å€¼ (c): {result.c}</p>
              <p>æœƒå¿ƒæ©Ÿç‡ (p_c): {result.p_c}</p>
              <p>å‘½ä¸­ç‡ (r_h): {result.r_h}</p>
              <p>æ ¼æ“‹ç‡ (r_b): {result.r_b}</p>
              <p>æœƒå¿ƒå¯¦éš›æ©Ÿç‡ (p_h): {result.p_h}</p>
              <p>æœƒå¿ƒå‚·å®³å€ç‡ (m_c): {result.m_c}</p>
              <p>ç¸½å€ç‡ (d_mul): {result.d_mul}</p>
              <p>æ°£ç›¾å½±éŸ¿å€¼ (G): {result.G}</p>
              <p>æœ€çµ‚æ”»æ“ŠåŠ› (A): {result.A}</p>
              <p>é˜²ç¦¦æ¸›å…ç‡ (Î³): {result.gamma}</p>
              <p>å…ƒç´ æŠ—åŠ› (Î²): {result.beta}</p>
              <p>åŸºç¤å‚·å®³: {result.baseDamage}</p>
              <p>æœ€çµ‚å‚·å®³: {result.finalDamage}</p>
              <p>ç¸½æ¸›å‚·ç‡: {result.totalReduction}</p>
              <p>æœ‰æ•ˆè¡€é‡ (EHP): {result.ehp}</p>
              <p>åŸºç¤å…ƒç´ å‚·å®³: {result.base_elementalDamage}</p>
              <p>æœ€çµ‚å…ƒç´ å‚·å®³: {result.elementalDamage}</p>
              <p>åŸºç¤å…ƒç´ å‚·å®³å æ¯”: {result.base_elementalDamagePrecentage}</p>
              <p>æœ€çµ‚å…ƒç´ å‚·å®³å æ¯”: {result.elementalDamagePrecentage}</p>
            </div>
          </div>
          {previousResult && (
            <div>
              <h3 className="font-bold text-gray-700 mb-2">ä¸Šæ¬¡çµæœ</h3>
              <div className="space-y-2 text-sm">
                <p>æœƒå¿ƒæ•¸å€¼ (c): {previousResult.c}</p>
                <p>æœƒå¿ƒç‡ (p_c): {previousResult.p_c}</p>
                <p>å‘½ä¸­ç‡ (r_h): {previousResult.r_h}</p>
                <p>æ ¼æ“‹ç‡ (r_b): {previousResult.r_b}</p>
                <p>æœƒè¨ˆå¯¦éš›æ©Ÿç‡ (p_h): {previousResult.p_h}</p>
                <p>æœƒå¿ƒå‚·å®³å€ç‡ (m_c): {previousResult.m_c}</p>
                <p>ç¸½å€ç‡ (d_mul): {previousResult.d_mul}</p>
                <p>æ°£ç›¾å½±éŸ¿å€¼ (G): {previousResult.G}</p>
                <p>æœ€çµ‚æ”»æ“ŠåŠ› (A): {previousResult.A}</p>
                <p>é˜²ç¦¦æ¸›å…ç‡ (Î³): {previousResult.gamma}</p>
                <p>å…ƒç´ æŠ—åŠ› (Î²): {previousResult.beta}</p>
                <p>åŸºç¤å‚·å®³: {previousResult.baseDamage}</p>
                <p>æœ€çµ‚å‚·å®³: {previousResult.finalDamage}</p>
                <p>ç¸½æ¸›å‚·ç‡: {previousResult.totalReduction}</p>
                <p>æœ‰æ•ˆè¡€é‡ (EHP): {previousResult.ehp}</p>
                <p>åŸºç¤å…ƒç´ å‚·å®³: {previousResult.base_elementalDamage}</p>
                <p>æœ€çµ‚å…ƒç´ å‚·å®³: {previousResult.elementalDamage}</p>
                <p>åŸºç¤å…ƒç´ å‚·å®³æ¯”: {previousResult.base_elementalDamagePrecentage}</p>
                <p>æœ€çµ‚å…ƒç´ å‚·å®³æ¯”: {previousResult.elementalDamagePrecentage}</p>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-white p-4 md:p-6 rounded-md shadow-md border border-gray-100">
        <h2 className="font-bold text-lg md:text-lg text-gray-800 mb-4">æ¸›å‚·ç‡åœ–è¡¨</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="font-bold text-gray-700 mb-2">æ¸›å‚·æ•ˆæœ</h3>
            <ResponsiveContainer width="100%" height="40vh">
              <LineChart data={deltaData} aria-label="æ¸›å‚·æ•ˆæœåœ–">
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="point" label={{ value: "å±¬æ€§å€¼", position: "below" }} />
                <YAxis tickFormatter={(value) => `${(value * 100).toFixed(2)}%`} label={{ value: "æ¸›å‚·æ•ˆæœ (%)", angle: -90, position: "left" }} />
                <Tooltip content={<CustomTooltip isDelta={true} />} />
                <Legend />
                <Line type="default" dataKey="ds" name="æ°£ç›¾" stroke="#ff0000" />
                <Line type="default" dataKey="dd" name="é˜²ç¦¦" stroke="#ff0" />
                <Line type="default" dataKey="df" name="æµæ´¾æŠµæŠ—" stroke="#00ff00" />
                <Line type="default" dataKey="de" name="å…ƒç´ æŠµæŠ—" stroke="#0ff" />
                <Line type="default" dataKey="bb" name="æ ¼æ“‹" stroke="#f0f" />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <div>
            <h3 className="font-bold text-gray-700 mb-2">ç¸½è¨ˆæ¸›å‚·ç‡</h3>
            <ResponsiveContainer width="100%" height="40vh">
              <LineChart data={reductionData} aria-label="ç¸½è¨ˆæ¸›å‚·ç‡">
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="point" label={{ value: "å±¬æ€§å€¼", position: "below" }} />
                <YAxis tickFormatter={(value) => `${(value * 100).toFixed(2)}%`} label={{ value: "ç¸½è¨ˆæ¸›å‚·ç‡ (%)", angle: -90, position: "left" }} />
                <Tooltip content={<CustomTooltip isDelta={false} />} />
                <Legend />
                <Line type="default" dataKey="ds" name="æ°£ç›¾" stroke="#f00" />
                <Line type="default" dataKey="dd" name="é˜²ç¦¦" stroke="#ff0" />
                <Line type="default" dataKey="df" name="æµæ´¾æŠµæŠ—" stroke="#0f0" />
                <Line type="default" dataKey="de" name="å…ƒç´ æŠµæŠ—" stroke="#0ff" />
                <Line type="default" dataKey="bb" name="æ ¼æ“‹" stroke="#f0f" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>
    </div>
  );
};

const DamageCalculator2 = () => {
  const [inputs, setInputs] = React.useState({
    skill_multiplier: "1518",
    D: "0",
    E: "800",
    b_c: "0",
    d_c: "1.8",
    R: "0",
    h: "500",
    b_d: "0",
    b_s: "0",
    b_e: "0",
    flow_percent: "0",
    damage_increase: "0",
    skill_damage_increase: "0",
    d_s: "2000",
    d_f: "2000",
    d_d: "0",
    d_e: "0",
    b_b: "0",
    hp: "80000",
    b_c_defense: "0",
    d_c_defense: "0",
    flow_resist_percent: "0",
    damage_reduction: "0",
    skill_damage_reduction: "0",
    lambda_1: SYSTEM_CONSTANTS.lambda_1.toString(),
    lambda_2: SYSTEM_CONSTANTS.lambda_2.toString(),
    lambda_3: "0",
    lambda_4: "0",
    W: "0",
    gold_i: "0"
  });
  const [inputErrors, setInputErrors] = React.useState({});
  const [previousResult, setPreviousResult] = React.useState(null);
  const [previousInputs, setPreviousInputs] = React.useState(null);

  const goldOptions = [
    { value: "0", label: "ç„¡é‡‘å±¬" },
    { value: "0.03", label: "é‡‘å±¬ 1ç´š" },
    { value: "0.04", label: "é‡‘å±¬ 2ç´š" },
    { value: "0.05", label: "é‡‘å±¬ 3ç´š" },
  ];

  const elementalDamageOptions = [
    { value: "0", label: "ç„¡å…ƒç´ " },
    { value: "1.5", label: "å…ƒç´ å¼±é»" },
  ];

  const handleChange = (e) => {
    const { name, value } = e.target;
    if (name === 'gold_i' || name === 'W') {
      setInputs((prev) => ({ ...prev, [name]: value }));
      setInputErrors((prev) => ({ ...prev, [name]: '' }));
    } else {
      if (value === '') {
        setInputs((prev) => ({ ...prev, [name]: '0' }));
        setInputErrors((prev) => ({ ...prev, [name]: '' }));
        return;
      }
      const numValue = parseFloat(value);
      if (isNaN(numValue)) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è«‹è¼¸å…¥æœ‰æ•ˆæ•¸å­—' }));
        return;
      }
      if (numValue < 0) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
        return;
      }
      if (numValue > 100000) {
        setInputErrors((prev) => ({ ...prev, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§ç‚º100000' }));
        return;
      }
      if (['flow_percent', 'damage_increase', 'skill_damage_increase', 'd_c_defense', 'flow_resist_percent', 'damage_reduction', 'skill_damage_reduction'].includes(name)) {
        if (numValue < 0 || numValue > 1) {
          setInputErrors((prev) => ({ ...prev, [name]: 'ç™¾åˆ†æ¯”å€¼å¿…é ˆåœ¨0åˆ°1ä¹‹é–“' }));
          return;
        }
      }
      setInputs((prev) => ({ ...prev, [name]: value }));
      setInputErrors((prev) => ({ ...prev, [name]: '' }));
    }
  };

  const saveCurrentResult = () => {
    setPreviousResult(calculateDamage(inputs));
    setPreviousInputs({ ...inputs });
  };

  const CustomTooltip = ({ active, payload, label, isDelta }) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white p-3 border rounded-lg shadow-sm">
          <p className="text-sm text-gray-700 font-medium">å±¬æ€§é»: {label}</p>
          {payload.map((entry, index) => (
            <p key={index} className="text-sm text-gray-600">
              <span style={{ color: entry.stroke }}>{entry.name}</span>: {(entry.value * 100).toFixed(isDelta ? 4 : 2)}%
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  const result = calculateDamage(inputs);
  const { deltaData, cumulativeData } = generateAttackChartData(inputs);

  return (
    <div className="p-4 container mx-auto min-h-screen">
      <div className="cherry-gradient rounded-xl p-6 mb-6 shadow-lg">
        <h1 className="text-xl md:text-2xl font-bold text-center text-white">æ”»æ“Šè¨ˆç®—å™¨</h1>
        <p className="text-center text-white text-opacity-90 text-sm mt-1">å¦‚æœ‰å•é¡Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@æ°¸æ†</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
          <div className="flex items-center mb-4">
            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
            <h2 className="font-bold text-base md:text-lg text-gray-800">æ”»æ“Šè€…åƒæ•¸</h2>
          </div>
          <ImageUploader setInputs={setInputs} type="attacker" />
          <div className="grid grid-cols-1 gap-3">
            {[
              { key: "skill_multiplier", label: "æŠ€èƒ½å€ç‡", icon: "ğŸ”¥", tooltip: "å¦‚æŠ€èƒ½å€ç‡100%ï¼Œè¼¸å…¥100" },
              { key: "D", label: "æ”»æ“Š", icon: "âš”ï¸" },
              { key: "E", label: "å…ƒç´ æ”»æ“Š", icon: "âœ©" },
              { key: "b_c", label: "æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
              { key: "d_c", label: "æœƒå¿ƒå‚·å®³", icon: "ğŸ’¥", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚180%ï¼Œè¼¸å…¥1.8" },
              { key: "R", label: "æµæ´¾å…‹åˆ¶", icon: "ğŸ”„" },
              { key: "h", label: "å‘½ä¸­", icon: "ğŸ¯" },
              { key: "b_d", label: "ç ´é˜²", icon: "ğŸ–Œ" },
              { key: "b_s", label: "ç ´ç›¾", icon: "ğŸ”¨" },
              { key: "b_e", label: "å¿½è¦–å…ƒç´ æŠµæŠ—", icon: "ğŸ¦ " },
              { key: "flow_percent", label: "æµæ´¾å…‹åˆ¶%", icon: "ğŸ“Š", tooltip: "ä¾‹å¦‚9.5%ï¼Œè¼¸å…¥0.095" },
              { key: "damage_increase", label: "å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "skill_damage_increase", label: "æŠ€èƒ½å¢å‚·%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "gold_i", label: "é‡‘å±¬", icon: "ğŸŒŸ", type: "select", options: goldOptions },
              { key: "W", label: "å…ƒç´ å‚·å®³", icon: "ğŸ¦‹", type: "select", options: elementalDamageOptions }
            ].map(({ key, label, icon, type, options, tooltip }) => (
              <div key={label} className="flex flex-col group relative">
                <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                  <span className="mr-2">{icon}</span>{label}
                  {tooltip && (
                    <>
                      <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 text-white text-xs cursor-pointer ml-2">?</span>
                      <div className="tooltip-hidden absolute left-0 top-8 bg-cherry-50 text-cherry-700 text-xs p-2 rounded shadow-md z-10 max-w-xs">
                        {tooltip}
                      </div>
                    </>
                  )}
                </label>
                {type === "select" ? (
                  <select
                    name={key}
                    value={inputs[key]}
                    onChange={handleChange}
                    className="input-focus border-gray-200 rounded-md p-2 text-sm w-full"
                    aria-label={label}
                  >
                    {options.map(opt => (
                      <option key={opt.value} value={opt.value}>{opt.label}</option>
                    ))}
                  </select>
                ) : (
                  <input
                    type="number"
                    name={key}
                    value={inputs[key]}
                    onChange={handleChange}
                    min="0"
                    max="100000"
                    className={`input-focus border ${inputErrors[key] ? 'border-red-500' : 'border-gray-200'} rounded-md p-2 text-sm w-full`}
                    aria-label={label}
                  />
                )}
                {inputErrors[key] && (
                  <p className="text-xs text-red-600 mt-1">{inputErrors[key]}</p>
                )}
              </div>
            ))}
          </div>
        </div>

        <div className="bg-white p-4 md:p-6 rounded-xl shadow-md border border-gray-100">
          <div className="flex items-center mb-4">
            <div className="w-1.5 h-5 rounded-full bg-cherry-500 mr-2"></div>
            <h2 className="font-bold text-base md:text-lg text-gray-800">é˜²å®ˆè€…åƒæ•¸</h2>
          </div>
          <ImageUploader setInputs={setInputs} type="defender" />
          <div className="grid grid-cols-1 gap-3">
            {[
              { key: "d_s", label: "æ°£ç›¾", icon: "ğŸ›¡ï¸" },
              { key: "d_f", label: "æµæ´¾æŠµæŠ—", icon: "ğŸ”„" },
              { key: "d_d", label: "é˜²ç¦¦", icon: "ğŸ°" },
              { key: "d_e", label: "å…ƒç´ æŠµæŠ—", icon: "ğŸ¦ " },
              { key: "b_b", label: "æ ¼æ“‹", icon: "âœ‹" },
              { key: "hp", label: "æ°£è¡€", icon: "â¤ï¸" },
              { key: "b_c_defense", label: "æŠ—æœƒå¿ƒæ•¸å€¼", icon: "ğŸ¯" },
              { key: "d_c_defense", label: "æœƒå¿ƒé˜²ç¦¦%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚25%ï¼Œè¼¸å…¥0.25" },
              { key: "flow_resist_percent", label: "æµæ´¾æŠµæŠ—%", icon: "ğŸ“Š", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
              { key: "damage_reduction", label: "å‚·å®³æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚15%ï¼Œè¼¸å…¥0.15" },
              { key: "skill_damage_reduction", label: "æŠ€èƒ½æ¸›å…%", icon: "ğŸ“‰", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" }
            ].map(({ key, label, icon, tooltip }) => (
              <div key={label} className="flex flex-col group relative">
                <label className="text-xs md:text-sm text-gray-600 mb-1 flex items-center">
                  <span className="mr-2">{icon}</span>
                  {label}
                  {tooltip && (
                    <>
                      <span className="flex items-center justify-center w-4 h-4 rounded-full bg-gray-200 text-white text-xs cursor-pointer ml-2">
                        ?
                      </span>
                      <div className="tooltip-content absolute left-0 top-8 bg-white text-gray-900 text-xs p-2 rounded shadow-md z-10 hidden group-hover:block max-w-xs">
                        {tooltip}
                      </div>
                    </>
                  )}
                </label>
                <input
                  type="number"
                  name={key}
                  value={inputs[key]}
                  onChange={handleChange}
                  min="0"
                  max="10000"
                  className={`input-field border ${inputErrors[key] ? 'border-red-500' : 'border-gray-300'} rounded-md p-2 text-sm w-full`}
                  aria-label={label}
                />
                {inputErrors[key] && (
                  <p className="text-red-600 mt-1">{inputErrors[key]}</p>
                )}
              </div>
            ))}
          </div>
        </div>

        <div className="bg-white p-4 rounded-md shadow-md border-gray-100">
          <div className="flex items-center mb-3">
            <div className="w-2 h-5 rounded-full bg-red-500 mr-2"></div>
            <h3 className="font-semibold text-base text-gray-800">ç³»çµ±åƒæ•¸</h3>
          </div>
          <div className="grid grid-cols-1 gap-2">
            {[
              { key: "lambda_1", label: "ç³»çµ±åƒæ•¸ Î»â‚", icon: "Î»", value: SYSTEM_CONSTANTS.lambda_1 },
              { key: "lambda_2", label: "ç³»çµ±åƒæ•¸ Î»â‚‚", icon: "Î»", value: SYSTEM_CONSTANTS.lambda_2 },
              { key: "lambda_3", label: "ç³»çµ±åƒæ•¸ Î»â‚ƒ", icon: "Î»", value: SYSTEM_CONSTANTS.lambda_3 },
              { key: "lambda_4", label: "ç³»çµ±åƒæ•¸ Î»â‚„", icon: "Î»", value: SYSTEM_CONSTANTS.lambda_4 },
            ].map(({ key, label, icon, value }) => (
              <div key={label} className="flex flex-col">
                <label className="text-sm text-gray-700 mb-1 flex items-center">
                  <span className="mr-2">{icon}</span>{label}
                </label>
                <input
                  type="number"
                  value={value}
                  disabled
                  className="border-gray-300 p-2 rounded-md text-sm bg-gray-100 w-full"
                  aria-label={label}
                />
              </div>
            ))}
          </div>
        </div>

      <div className="flex justify-center mb-4">
        <button
          type="button"
          onClick={saveCurrentResult}
          className="bg-red-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-700"
          aria-label="å„²å­˜çµæœ"
        >
          å„²å­˜çµæœ
        </button>
      </div>

      <div className="bg-white p-4 rounded-md shadow-md border-gray-100 mb-4">
        <h2 className="font-semibold text-lg text-gray-800 mb-4">è¨ˆç®—çµæœ</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="font-semibold text-gray-700 mb-2">ç•¶å‰è¨ˆç®—çµæœ</h3>
            <div className="space-y-2 text-sm">
              <p>æœƒå¿ƒæ“Šå€¼ (c): {result.c}</p>
              <p>æœƒå¿ƒç‡ (p_c): {result.p_c}</p>
              <p>å‘½ä¸­ç‡ (r_h): {result.r_h}</p>
              <p>æ ¼æ“‹ç‡ (r_b): {result.r_b}</p>
              <p>æœƒå¿ƒå¯¦éš›ç‡ (p_h): {result.p_h}</p>
              <p>æœƒå¿ƒå‚·å®³å€ç‡ (m_c): {result.m_c}</p>
              <p>ç¸½å€ç‡ (d_mul): {result.d_mul}</p>
              <p>æ°£ç›¾å½±éŸ¿å€¼ (G): {result.G}</p>
              <p>æœ€çµ‚æ”»æ“ŠåŠ› (A): {result.A}</p>
              <p>é˜²ç¦¦æ¸›å…ç‡ (Î³): {result.gamma}</p>
              <p>å…ƒç´ æŠµæŠ—ç‡ (Î²): {result.beta}</p>
              <p>åŸºç¤å‚·å®³: {result.baseDamage}</p>
              <p>æœ€çµ‚å‚·å®³: {result.finalDamage}</p>
              <p>ç¸½æ¸›å‚·ç‡: {result.totalReduction}</p>
              <p>æœ‰æ•ˆè¡€é‡ (EHP): {result.ehp}</p>
              <p>åŸºç¤å…ƒç´ å‚·å®³: {result.base_elementalDamage}</p>
              <p>æœ€çµ‚å…ƒç´ å‚·å®³: {result.elementalDamage}</p>
              <p>åŸºç¤å…ƒç´ å‚·å®³æ¯”: {result.base_elementalDamagePrecentage}</p>
              <p>æœ€çµ‚å…ƒç´ å‚·å®³æ¯”: {result.elementalDamagePrecentage}</p>
            </div>
          </div>
          {previousResult && (
            <div>
              <h3 className="font-semibold text-gray-700 mb-2">ä¸Šæ¬¡è¨ˆç®—çµæœ</h3>
              <div className="space-y-2 text-sm">
                <p>æœƒå¿ƒæ“Šå€¼ (c): {previousResult.c}</p>
                <p>æœƒå¿ƒç‡ (p_c): {previousResult.p_c}</p>
                <p>å‘½ä¸­ç‡ (r_h): {previousResult.r_h}</p>
                <p>æ ¼æ“‹ç‡ (r_b): {previousResult.r_b}</p>
                <p>æœƒå¿ƒå¯¦éš›ç‡ (p_h): {previousResult.p_h}</p>
                <p>æœƒå¿ƒå‚·å®³å€ç‡ (m_c): {previousResult.m_c}</p>
                <p>ç¸½å€ç‡ (d_mul): {previousResult.d_mul}</p>
                <p>æ°£ç›¾å½±éŸ¿å€¼ (G): {previousResult.G}</p>
                <p>æœ€çµ‚æ”»æ“ŠåŠ› (A): {previousResult.A}</p>
                <p>é˜²ç¦¦æ¸›å…ç‡ (Î³): {previousResult.gamma}</p>
                <p>å…ƒç´ æŠµæŠ—ç‡ (Î²): {previousResult.beta}</p>
                <p>åŸºç¤å‚·å®³: {previousResult.baseDamage}</p>
                <p>æœ€çµ‚å‚·å®³: {previousResult.finalDamage}</p>
                <p>ç¸½æ¸›å‚·ç‡: {previousResult.totalReduction}</p>
                <p>æœ‰æ•ˆè¡€é‡ (EHP): {previousResult.ehp}</p>
                <p>åŸºç¤å…ƒç´ å‚·å®³: {previousResult.base_elementalDamage}</p>
                <p>æœ€çµ‚å…ƒç´ å‚·å®³: {previousResult.elementalDamage}</p>
                <p>åŸºç¤å…ƒç´ å‚·å®³æ¯”: {previousResult.base_elementalDamagePrecentage}</p>
                <p>æœ€çµ‚å…ƒç´ å‚·å®³æ¯”: {previousResult.elementalDamagePrecentage}</p>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-white p-4 rounded-md shadow-md border-gray-100">
        <h2 className="font-semibold text-lg text-gray-800 mb-4">å±¬æ€§æ”¶ç›Šåœ–è¡¨</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="font-semibold text-gray-700 mb-2">å‚·å®³å¢é‡</h3>
            <ResponsiveContainer width="100%" height="40vh">
              <LineChart data={deltaData} aria-label="å‚·å®³å¢é‡åœ–è¡¨">
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="point" label={{ value: "å±¬æ€§å€¼", position: "below" }} />
                <YAxis tickFormatter={(value) => `${(value * 100).toFixed(2)}%`} label={{ value: "å‚·å®³å¢é‡ (%)", angle: -90, position: "left" }} />
                <Tooltip content={<CustomTooltip isDelta={true} />} />
                <Legend />
                <Line type="default" dataKey="b_d" name="ç ´é˜²" stroke="#f00" />
                <Line type="default" dataKey="b_e" name="å¿½è¦–å…ƒç´ æŠµæŠ—" stroke="#0f0" />
                <Line type="default" dataKey="D" name="æ”»æ“Š" stroke="#00f" />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <div>
            <h3 className="font-semibold text-gray-700 mb-2">ç¸½å‚·å®³å¢ç›Š</h3>
            <ResponsiveContainer width="100%" height="40vh">
              <LineChart data={cumulativeData} aria-label="ç¸½å‚·å®³å¢ç›Šåœ–">
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="point" label={{ value: "å±¬æ€§å€¼", position: "below" }} />
                <YAxis tickFormatter={(value) => `${(value * 100).toFixed(2)}%`} label={{ value: "ç¸½å‚·å®³å¢ç›Š (%)", angle: "-90", position: "left" }} />
                <Tooltip content={<CustomTooltip isDelta={false} />} />
                <Legend />
                <Line type="default" dataKey="b_d" name="ç ´é˜²" stroke="#f00" />
                <Line type="default" dataKey="b_e" name="å¿½è¦–å…ƒç´ æŠµæŠ—" stroke="#0f0" />
                <Line type="default" dataKey="D" name="æ”»æ“Š" stroke="#00f" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>
    </div>
  );
};

const HealingCalculator = () => {
  const [inputs, setHealing] = useState({
    healing_power: "0",
    healing: "0",
    flat: "0",
    power_bonus: "0",
  });
  const [errorInputs, setErrors] = React.useState({});

  const handleChange = (event) => {
    const { name, value } = event.target;
    if (value === '') {
      setHealing((prev) => ({ ...prev, [name]: '0' }));
      setErrors((prevResult) => ({ ...prevResult, [name]: '' }));
      return;
    }
    const numericValue = parseFloat(value);
    if (isNaN(numericValue)) {
      setErrors((prevResult) => ({ ...prevResult, [name]: 'è«‹è¼¸å…¥æœ‰æ•ˆæ•¸å­—' }));
      return;
    }
    if (numericValue < 0) {
      setErrors((prevResult) => ({ ...prevResult, [name]: 'è¼¸å…¥å€¼ä¸èƒ½ç‚ºè² æ•¸' }));
      return;
    }
    if (numericValue > 100000) {
      setErrors((prevResult) => ({ ...prevResult, [name]: 'è¼¸å…¥å€¼éå¤§ï¼Œæœ€å¤§å€¼100000' }));
      return;
    }
    if (['healing_percent', 'healing_power_bonus'].includes(name)) {
      if (numericValue < 0 || numericValue > 1) {
        setErrors((prevResult) => ({ ...prevResult, [name]: 'ç™¾åˆ†æ¯”å€¼å¿…é ˆåœ¨0åˆ°1ä¹‹é–“' }));
        return;
      }
    }
    setHealing((prev) => ({ ...prevResult, [name]: value }));
    setErrors((prevResult) => ({ ...prevResult, [name]: '' }));
  };

  const calculateHealing = () => {
    const healing_power_equip = toNum(inputs.healing_power_equip);
    const healing_power = toNum(inputs.healing_power);
    const base_healing = toNum(inputs.healing_base);
    const healing_power_bonus = toNum(inputs.healing_power_bonus);

    const total_healing_power = healing_power_equip + healing_power;
    const final_healing = total_healing_power * (1 + healing_percent + healing_power_bonus);

    return {
      total_healing_power: total_healing_power.toFixed(2),
      final_healing: final_healing.toFixed(2),
    };
  };

  const result = calculateHealing();

  return (
    <div className="p-6 container mx-auto">
      <div className="gradient-bg p-6 rounded-md shadow-md mb-6 text-center">
        <h2 className="text-xl md:text-2xl font-semibold text-white">æ²»ç™‚è¨ˆç®—å™¨</h2>
        <p className="text-white text-opacity-80 text-sm mt-1">å¦‚æœ‰å•é¡Œï¼Œè«‹è¯ç¹«æ«»æ¡ƒç™½è˜­åœ°@æ°¸æ†</p>
      </div>

      <div className="bg-white p-4 md:p-6 rounded-md shadow-md border-gray-100 mb-6">
        <div className="flex items-center mb-4">
          <div className="w-2 h-4 rounded-full bg-blue-500 mr-2"></div>
          <h3 className="font-semibold text-base text-gray-800">è¼¸å…¥åƒæ•¸</h3>
        </div>
        <ImageUploader setInputs={setInputs} type="heal" />
        <div className="grid grid-cols-1 gap-2">
          {[
            { key: "healing_power_equip", label: "è£å‚™æ²»ç™‚å¼·åº¦", icon: "ğŸ©º" },
            { key: "healing_power", label: "åŸºç¤æ²»ç™‚å¼·åº¦", icon: "ğŸ’‰" },
            { key: "healing_percent", label: "æ²»ç™‚åŠ æˆ%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚10%ï¼Œè¼¸å…¥0.1" },
            { key: "healing_power_bonus", label: "é¡å¤–æ²»ç™‚åŠ æˆ%", icon: "ğŸ“ˆ", tooltip: "é™¤ä»¥100ï¼Œä¾‹å¦‚5%ï¼Œè¼¸å…¥0.05" },
          ].map(({ key, label, icon, tooltip }) => (
            <div key={label} className="flex flex-col group relative">
              <label className="text-sm text-gray-700 mb-1 flex items-center">
                <span className="mr-2">{icon}</span>{label}
                {tooltip && (
                  <>
                    <span className="flex items-center justify-center w-4 h-4 bg-gray-200 rounded-full text-white text-xs cursor-pointer ml-2">?</span>
                    <div className="tooltip-content absolute left-0 top-8 bg-white text-gray-900 text-xs p-2 rounded shadow-md hidden group-hover-md:block max-w-xs ml-2">
                      {tooltip}
                    </div>
                  </>
                )}
              </label>
              <input
                type="number"
                name={key}
                value={inputs[key]}
                onChange={handleChange}
                min="0"
                max="10000"
                className={`input-field border ${inputErrors[key] ? 'border-red-500' : 'border-gray-300'}`} rounded-md p-2 text-sm w-full`}
                aria-label={label}
              />
              {inputErrors[key] && (
                <p className="text-sm text-red-600 mt-1">{inputErrors[key]}</p>
              )}
            </div>
          ))}
        </div>
      </div>

      <div className="bg-white rounded-md shadow-md p-4 md:p-6">
        <h2 className="font-semibold text-lg text-gray-800 mb-1">è¨ˆç®—çµæœ</h2>
        <div className="space-y-2 text-sm">
          <p>ç¸½æ²»ç™‚æ•ˆæœ: {result.total_healing_power}</p>
          <p>æœ€çµ‚æ²»ç™‚é‡: {result.final_healing}</p>
        </div>
      </div>
    );
};

const App = () => {
  const [activeTab, setTab] = React.useState('defense');
  const [isSidebarOpen, setSidebarOpen] = React.useState(false);

  const toggleSidebar = () => {
    setSidebarOpen(!isSidebarOpen);
  };

  return (
    <div className="relative">
      <button
        className="md:hidden fixed top-4 left-4 z-50 bg-red-500 text-white p-2 rounded-lg"
        onClick={toggleSidebar}
        aria-label="é–‹é—œå´é‚Šæ¬„"
      >
        â˜°
      </button>

      <div className={`sidebar fixed top-0 left-0 h-full w-64 bg-white shadow-lg p-4 transform ${isSidebarOpen ? 'open' : ''} md:transform-none z-40`}>
        <div className="flex items-center mb-6">
          <div className="w-2 h-6 rounded-full bg-red-500 mr-2"></div>
          <h2 className="text-xl font-semibold text-gray-800">éŠæˆ²è¨ˆç®—å™¨</h2>
        </div>
        <nav className="space-y-2">
          <button
            className={`w-full text-left py-2 px-4 rounded-lg ${activeTab === 'defense' ? 'bg-red-100 text-red-700' : 'text-gray-600 hover:bg-gray-100'}`}
            onClick={() => { setTab('defense'); setSidebarOpen(false); }}
            aria-label="åˆ‡æ›åˆ°é˜²å®ˆè¨ˆç®—å™¨"
          >
            é˜²å®ˆè¨ˆç®—å™¨
          </button>
          <button
            className={`w-full text-left py-2 px-4 rounded-lg ${activeTab === 'attack' ? 'bg-red-100 text-red-700' : 'text-gray-600 hover:bg-gray-100'}`}
            onClick={() => { setTab('attack'); setSidebarOpen(false); }}
            aria-label="åˆ‡æ›åˆ°æ”»æ“Šè¨ˆç®—å™¨"
          >
            æ”»æ“Šè¨ˆç®—å™¨
          </button>
          <button
            className={`w-full text-left py-2 px-4 rounded-lg ${activeTab === 'healing' ? 'bg-red-100 text-red-700' : 'text-gray-600 hover:bg-gray-100'}`}
            onClick={() => { setTab('healing'); setSidebarOpen(false); }}
            aria-label="åˆ‡æ›åˆ°æ²»ç™‚è¨ˆç®—å™¨"
          >
            æ²»ç™‚è¨ˆç®—å™¨
          </button>
        </nav>
      </div>

      <div className="md:ml-64 p-4">
        {activeTab === 'defense' && <DamageCalculator />}
        {activeTab === 'attack' && <DamageCalculator2 />}
        {activeTab === 'healing' && <HealingCalculator />}
      </div>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);